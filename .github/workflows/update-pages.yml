name: Update GitHub Pages

on:
  # Trigger when builds complete (using repository_dispatch from build workflow)
  repository_dispatch:
    types: [build-completed]
  # Trigger when releases are published/edited
  release:
    types:
      - published
      - edited
  # Manual trigger
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update pages'
        required: false
        type: boolean
        default: false
      target_branch:
        description: 'Target branch for build info (main/dev/both)'
        required: false
        type: choice
        options:
          - both
          - main
          - dev
        default: both

permissions:
  contents: read   # Only need read permission since we're not committing back
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  update-build-info:
    name: Update Build Information
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'repository_dispatch' || github.event_name == 'release' }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: dev  # Always checkout dev branch since that's where GitHub Pages deploys from
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.12"

    - name: Log trigger information
      run: |
        echo "=== Workflow Trigger Information ==="
        echo "Event name: ${{ github.event_name }}"
        echo "Repository: ${{ github.repository }}"
        echo "Ref: ${{ github.ref }}"
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          echo "Dispatch type: ${{ github.event.action }}"
          echo "Client payload: ${{ toJson(github.event.client_payload) }}"
        elif [ "${{ github.event_name }}" = "release" ]; then
          echo "Release action: ${{ github.event.action }}"
          echo "Release tag: ${{ github.event.release.tag_name }}"
          echo "Release name: ${{ github.event.release.name }}"
        fi
        echo "=================================="

    - name: Get latest build information
      id: build-info
      run: |
        # Get latest successful workflow runs for main and dev branches
        echo "Fetching build information..."

        # Determine which branches to fetch based on input or trigger
        FETCH_BRANCHES="main dev"
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ inputs.target_branch }}" != "both" ]; then
          FETCH_BRANCHES="${{ inputs.target_branch }}"
        elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          # For repository_dispatch events (build completed), only update dev branch
          FETCH_BRANCHES="dev"
        elif [ "${{ github.event_name }}" = "release" ]; then
          # For release events, update both branches (release affects main, but we want both updated)
          FETCH_BRANCHES="main dev"
        fi

        echo "Fetching build info for branches: $FETCH_BRANCHES"

        # Function to get latest release info for main branch
        get_release_info() {
          echo "Fetching latest release info..." >&2

          local release_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/latest")

          local tag_name=$(echo "$release_info" | jq -r '.tag_name // empty')
          local published_at=$(echo "$release_info" | jq -r '.published_at // empty')
          local target_commitish=$(echo "$release_info" | jq -r '.target_commitish // empty')

          if [ -n "$tag_name" ] && [ "$tag_name" != "null" ] && [ "$tag_name" != "empty" ]; then
            # Remove 'v' prefix if present (e.g., v0.9.2 -> 0.9.2)
            local version=$(echo "$tag_name" | sed 's/^v//')

            # Format the date nicely
            local formatted_date=$(date -d "$published_at" "+%Y-%m-%d %H:%M UTC" 2>/dev/null || echo "$published_at")

            echo "main_version=${version}"
            echo "main_date=${formatted_date}"
            echo "main_run_id="
            echo "main_commit=${target_commitish}"

            echo "✓ Found release: version=$version, date=$formatted_date" >&2
          else
            echo "main_version=No releases available"
            echo "main_date=N/A"
            echo "main_run_id="
            echo "main_commit="
            echo "⚠ No releases found" >&2
          fi
        }

        # Function to get latest successful run info for dev branch
        get_build_info() {
          local branch=$1
          echo "Fetching build info for branch: $branch" >&2

          local run_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build.yml/runs?branch=${branch}&status=success&per_page=1")

          local run_id=$(echo "$run_info" | jq -r '.workflow_runs[0].id // empty')
          local run_date=$(echo "$run_info" | jq -r '.workflow_runs[0].created_at // empty')
          local commit_sha=$(echo "$run_info" | jq -r '.workflow_runs[0].head_sha // empty')

          if [ -n "$run_id" ] && [ "$run_id" != "null" ] && [ "$run_id" != "empty" ]; then
            # Get artifacts for this run
            local artifacts=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${run_id}/artifacts")

            # Extract version from artifact name (assumes format: windows-installer-X.Y.Z)
            local version=$(echo "$artifacts" | jq -r '.artifacts[] | select(.name | startswith("windows-installer-")) | .name' | sed 's/windows-installer-//' | head -1)

            if [ -z "$version" ] || [ "$version" = "null" ] || [ "$version" = "" ]; then
              # Fallback: try to get version from pyproject.toml
              version=$(python -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])" 2>/dev/null || echo "unknown")
            fi

            # Format the date nicely
            local formatted_date=$(date -d "$run_date" "+%Y-%m-%d %H:%M UTC" 2>/dev/null || echo "$run_date")

            echo "${branch}_version=${version}"
            echo "${branch}_date=${formatted_date}"
            echo "${branch}_run_id=${run_id}"
            echo "${branch}_commit=${commit_sha}"

            echo "✓ Found build for $branch: version=$version, date=$formatted_date" >&2
          else
            echo "${branch}_version=No builds available"
            echo "${branch}_date=N/A"
            echo "${branch}_run_id="
            echo "${branch}_commit="
            echo "⚠ No successful builds found for $branch" >&2
          fi
        }

        # Get info for specified branches
        for branch in $FETCH_BRANCHES; do
          if [ "$branch" = "main" ]; then
            # For main branch, get release info from GitHub releases
            get_release_info >> $GITHUB_OUTPUT
          else
            # For other branches (dev), get build info from workflow runs
            get_build_info "$branch" >> $GITHUB_OUTPUT
          fi
        done

    - name: Generate HTML from template
      run: |
        # Copy template to root directory and substitute values
        cp docs/index.template.html index.html

        # Get current timestamp
        LAST_UPDATED=$(date -u +"%Y-%m-%d %H:%M UTC")

        # Get build info values with fallbacks
        MAIN_VERSION="${{ steps.build-info.outputs.main_version }}"
        MAIN_DATE="${{ steps.build-info.outputs.main_date }}"
        MAIN_COMMIT="${{ steps.build-info.outputs.main_commit }}"
        DEV_VERSION="${{ steps.build-info.outputs.dev_version }}"
        DEV_DATE="${{ steps.build-info.outputs.dev_date }}"
        DEV_COMMIT="${{ steps.build-info.outputs.dev_commit }}"

        # Apply fallbacks if values are empty
        [ -z "$MAIN_VERSION" ] && MAIN_VERSION="Latest Release"
        [ -z "$MAIN_DATE" ] && MAIN_DATE="Check GitHub"
        [ -z "$MAIN_COMMIT" ] && MAIN_COMMIT=""
        [ -z "$DEV_VERSION" ] && DEV_VERSION="Development"
        [ -z "$DEV_DATE" ] && DEV_DATE="Check nightly.link"
        [ -z "$DEV_COMMIT" ] && DEV_COMMIT=""

        # Escape special characters for sed
        MAIN_VERSION=$(echo "$MAIN_VERSION" | sed 's/[[\.*^$()+?{|]/\\&/g')
        MAIN_DATE=$(echo "$MAIN_DATE" | sed 's/[[\.*^$()+?{|]/\\&/g')
        MAIN_COMMIT=$(echo "$MAIN_COMMIT" | sed 's/[[\.*^$()+?{|]/\\&/g')
        DEV_VERSION=$(echo "$DEV_VERSION" | sed 's/[[\.*^$()+?{|]/\\&/g')
        DEV_DATE=$(echo "$DEV_DATE" | sed 's/[[\.*^$()+?{|]/\\&/g')
        DEV_COMMIT=$(echo "$DEV_COMMIT" | sed 's/[[\.*^$()+?{|]/\\&/g')
        LAST_UPDATED_ESCAPED=$(echo "$LAST_UPDATED" | sed 's/[[\.*^$()+?{|]/\\&/g')

        # Substitute template variables with actual values
        sed -i "s/{{MAIN_VERSION}}/$MAIN_VERSION/g" index.html
        sed -i "s/{{MAIN_DATE}}/$MAIN_DATE/g" index.html
        sed -i "s/{{MAIN_COMMIT}}/$MAIN_COMMIT/g" index.html
        sed -i "s/{{DEV_VERSION}}/$DEV_VERSION/g" index.html
        sed -i "s/{{DEV_DATE}}/$DEV_DATE/g" index.html
        sed -i "s/{{DEV_COMMIT}}/$DEV_COMMIT/g" index.html
        sed -i "s/{{LAST_UPDATED}}/$LAST_UPDATED_ESCAPED/g" index.html

        echo "✓ Generated index.html from template with build info:"
        echo "  Main: ${{ steps.build-info.outputs.main_version }} (${{ steps.build-info.outputs.main_date }})"
        echo "  Dev: ${{ steps.build-info.outputs.dev_version }} (${{ steps.build-info.outputs.dev_date }})"
        echo "  Last updated: $LAST_UPDATED"
        echo "  Triggered by: ${{ github.event_name }}"

        # Verify substitution worked
        if grep -q "{{" index.html; then
          echo "⚠ Warning: Some template variables may not have been substituted:"
          grep -o "{{[^}]*}}" index.html || true
        else
          echo "✓ All template variables successfully substituted"
        fi

    - name: Create nightly.link URLs documentation
      run: |
        # Get build info with fallbacks
        MAIN_VERSION="${{ steps.build-info.outputs.main_version }}"
        MAIN_DATE="${{ steps.build-info.outputs.main_date }}"
        DEV_VERSION="${{ steps.build-info.outputs.dev_version }}"
        DEV_DATE="${{ steps.build-info.outputs.dev_date }}"

        [ -z "$MAIN_VERSION" ] && MAIN_VERSION="latest"
        [ -z "$MAIN_DATE" ] && MAIN_DATE="Check GitHub"
        [ -z "$DEV_VERSION" ] && DEV_VERSION="latest"
        [ -z "$DEV_DATE" ] && DEV_DATE="Check nightly.link"

        cat > docs/download-links.md << EOF
        # AccessiWeather Download Links

        ## Stable Release (Main Branch)

        ### Direct Downloads:
        - **Installer**: https://nightly.link/Orinks/AccessiWeather/workflows/build/main/windows-installer-${MAIN_VERSION}.zip
        - **Portable**: https://nightly.link/Orinks/AccessiWeather/workflows/build/main/windows-portable-${MAIN_VERSION}.zip

        ## Development Release (Dev Branch)

        ### Direct Downloads:
        - **Installer**: https://nightly.link/Orinks/AccessiWeather/workflows/build/dev/windows-installer-${DEV_VERSION}.zip
        - **Portable**: https://nightly.link/Orinks/AccessiWeather/workflows/build/dev/windows-portable-${DEV_VERSION}.zip

        ## How to Use

        1. Choose your preferred download:
           - **Installer**: Download and run for guided installation
           - **Portable**: Download and extract for no-install usage
        2. No GitHub login required for public downloads
        3. Links always point to the latest successful build
        4. Each download is a separate, focused package

        ## Build Information

        - **Main Version**: ${MAIN_VERSION}
        - **Main Build Date**: ${MAIN_DATE}
        - **Dev Version**: ${DEV_VERSION}
        - **Dev Build Date**: ${DEV_DATE}
        - **Last Updated**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

        EOF

        echo "✓ Created download links documentation"

    - name: Disable Jekyll processing
      run: |
        # Create .nojekyll file to disable Jekyll processing
        # This ensures our static HTML is served as-is without Jekyll interference
        touch .nojekyll
        echo "✓ Created .nojekyll file to disable Jekyll processing"

    - name: Validate generated files
      run: |
        echo "📋 Validating generated files..."

        # Check if index.html exists and has content
        if [ -f "index.html" ]; then
          echo "✓ index.html exists ($(wc -l < index.html) lines)"

          # Check for remaining template variables
          if grep -q "{{" index.html; then
            echo "⚠ Warning: Found remaining template variables:"
            grep -n "{{[^}]*}}" index.html || true
          else
            echo "✓ No template variables remaining"
          fi

          # Check for key content
          if grep -q "AccessiWeather" index.html; then
            echo "✓ Contains expected content"
          else
            echo "❌ Missing expected content"
          fi
        else
          echo "❌ index.html not found!"
          exit 1
        fi

        # Check download-links.md
        if [ -f "docs/download-links.md" ]; then
          echo "✓ download-links.md exists ($(wc -l < docs/download-links.md) lines)"
        else
          echo "⚠ download-links.md not found"
        fi

        echo "📋 File validation complete"

    - name: Upload Pages artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: ./

  deploy-pages:
    name: Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: update-build-info
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
