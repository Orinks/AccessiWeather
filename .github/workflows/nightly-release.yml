name: Nightly Dev Prerelease

on:
  schedule:
    - cron: "30 3 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - skip actual release creation'
        type: boolean
        default: false
      force_build:
        description: 'Force build even if no changes detected'
        type: boolean
        default: false

permissions:
  contents: write
  actions: write

concurrency:
  group: nightly-release
  cancel-in-progress: true

defaults:
  run:
    shell: bash

env:
  FORCE_COLOR: "0"
  PYTHONUTF8: "1"
  PYTHON_VERSION: "3.12"

jobs:
  prepare:
    name: Check for changes
    runs-on: ubuntu-latest
    outputs:
      changed: ${{ steps.changes.outputs.changed }}
      version: ${{ steps.version.outputs.version }}
      previous_tag: ${{ steps.changes.outputs.previous_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Check for changes in src/ since last nightly
        id: changes
        run: |
          git fetch --tags

          # Get HEAD commit SHA
          HEAD_SHA=$(git rev-parse HEAD)
          echo "HEAD commit: $HEAD_SHA"

          # Check for force build
          if [ "${{ inputs.force_build }}" == "true" ]; then
            echo "Force build requested."
            echo "changed=true" >> "$GITHUB_OUTPUT"
            LAST_NIGHTLY_TAG=$(git tag --list "nightly-*" --sort=-version:refname | head -n 1)
            echo "previous_tag=$LAST_NIGHTLY_TAG" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Check if HEAD already has a nightly tag (already released)
          HEAD_TAGS=$(git tag --points-at HEAD | grep "^nightly-" || true)
          if [ -n "$HEAD_TAGS" ]; then
            echo "HEAD already has nightly tag(s): $HEAD_TAGS"
            echo "Skipping build - this commit was already released."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Find the latest nightly tag
          LAST_NIGHTLY_TAG=$(git tag --list "nightly-*" --sort=-version:refname | head -n 1)
          echo "Last nightly tag: $LAST_NIGHTLY_TAG"
          echo "previous_tag=$LAST_NIGHTLY_TAG" >> "$GITHUB_OUTPUT"

          if [ -z "$LAST_NIGHTLY_TAG" ]; then
            echo "No previous nightly tag found - first nightly build."
            echo "changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Get the commit SHA of the last nightly tag
          LAST_NIGHTLY_SHA=$(git rev-parse "$LAST_NIGHTLY_TAG^{commit}")
          echo "Last nightly commit: $LAST_NIGHTLY_SHA"

          # Check if there are ANY commits since last nightly (not just src/ changes)
          COMMIT_COUNT=$(git rev-list --count "$LAST_NIGHTLY_TAG"..HEAD)
          echo "Commits since last nightly: $COMMIT_COUNT"

          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "No new commits since last nightly."
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Check for meaningful changes in src/ or pyproject.toml
          if git diff --quiet "$LAST_NIGHTLY_TAG"..HEAD -- src/ pyproject.toml installer/; then
            echo "No changes in src/, pyproject.toml, or installer/ since last nightly."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Changes detected in src/, pyproject.toml, or installer/ since last nightly."
            git --no-pager diff --stat "$LAST_NIGHTLY_TAG"..HEAD -- src/ pyproject.toml installer/ | tail -20
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Get version
        id: version
        run: |
          VERSION=$(python3 -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

  build-windows:
    name: Build Windows
    runs-on: windows-latest
    needs: prepare
    if: needs.prepare.outputs.changed == 'true'
    outputs:
      version: ${{ steps.version.outputs.version }}
      success: ${{ steps.build-status.outputs.success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-nightly-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-nightly-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -e .[dev]
          pip install pyinstaller pillow

      - name: Get version
        id: version
        run: |
          # Just use the version from pyproject.toml
          VERSION=$(python -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Generate icons
        run: python installer/create_icons.py

      - name: Build with PyInstaller
        run: python -m PyInstaller --clean --noconfirm installer/accessiweather.spec

      - name: Install Inno Setup
        run: choco install innosetup -y --no-progress

      - name: Create Windows Installer
        run: |
          # Write version file for Inno Setup (from pyproject.toml)
          echo "[version]" > dist/version.txt
          echo "value=${{ steps.version.outputs.version }}" >> dist/version.txt
          "/c/Program Files (x86)/Inno Setup 6/ISCC.exe" installer/accessiweather.iss

      - name: Create portable ZIP
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          cd dist
          if [ -d "AccessiWeather_dir" ]; then
            7z a -tzip "AccessiWeather_Portable_v${VERSION}.zip" "AccessiWeather_dir/*"
          elif [ -f "AccessiWeather.exe" ]; then
            7z a -tzip "AccessiWeather_Portable_v${VERSION}.zip" "AccessiWeather.exe"
          fi

      - name: Set build status
        id: build-status
        if: always()
        run: |
          if [ -f dist/AccessiWeather_Setup_*.exe ]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Windows Installer
        uses: actions/upload-artifact@v6
        with:
          name: nightly-windows-installer
          path: dist/AccessiWeather_Setup_*.exe
          retention-days: 7

      - name: Upload Windows Portable
        uses: actions/upload-artifact@v6
        with:
          name: nightly-windows-portable
          path: dist/AccessiWeather_Portable_*.zip
          retention-days: 7

  build-macos:
    name: Build macOS
    runs-on: macos-latest
    needs: prepare
    if: needs.prepare.outputs.changed == 'true'
    outputs:
      version: ${{ steps.version.outputs.version }}
      success: ${{ steps.build-status.outputs.success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/pip
          key: ${{ runner.os }}-pip-nightly-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-nightly-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -e .[dev]
          pip install pyinstaller pillow
          brew install create-dmg || true

      - name: Get version
        id: version
        run: |
          # Just use the version from pyproject.toml
          VERSION=$(python -c "import tomllib; print(tomllib.load(open('pyproject.toml', 'rb'))['project']['version'])")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Generate icons
        run: python installer/create_icons.py

      - name: Build with PyInstaller
        run: python -m PyInstaller --clean --noconfirm installer/accessiweather.spec

      - name: Create DMG
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Try create-dmg first, fallback to hdiutil
          if command -v create-dmg &> /dev/null; then
            create-dmg \
              --volname "AccessiWeather" \
              --window-pos 200 120 \
              --window-size 600 400 \
              --icon-size 100 \
              --icon "AccessiWeather.app" 175 190 \
              --hide-extension "AccessiWeather.app" \
              --app-drop-link 425 190 \
              "dist/AccessiWeather_v${VERSION}.dmg" \
              "dist/AccessiWeather.app" || \
              hdiutil create -volname "AccessiWeather" -srcfolder "dist/AccessiWeather.app" -ov -format UDZO "dist/AccessiWeather_v${VERSION}.dmg"
          else
            hdiutil create -volname "AccessiWeather" -srcfolder "dist/AccessiWeather.app" -ov -format UDZO "dist/AccessiWeather_v${VERSION}.dmg"
          fi

      - name: Set build status
        id: build-status
        if: always()
        run: |
          if [ -f dist/AccessiWeather_*.dmg ]; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload macOS DMG
        uses: actions/upload-artifact@v6
        with:
          name: nightly-macos-dmg
          path: dist/AccessiWeather_*.dmg
          retention-days: 7

  nightly-release:
    name: Publish Nightly Release
    needs: [prepare, build-windows, build-macos]
    # Release if changes detected AND at least one build succeeded
    if: |
      always() &&
      needs.prepare.outputs.changed == 'true' &&
      (needs.build-windows.result == 'success' || needs.build-macos.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
          pattern: nightly-*
          merge-multiple: true
        continue-on-error: true

      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          ls -laR dist/ || echo "No artifacts downloaded"

      - name: Validate artifacts
        id: validate
        working-directory: dist
        run: |
          WINDOWS_OK="false"
          MACOS_OK="false"
          
          # Check for Windows artifacts
          if ls AccessiWeather_Setup_*.exe 1>/dev/null 2>&1 || ls *windows*.exe 1>/dev/null 2>&1; then
            WINDOWS_OK="true"
            echo "‚úì Windows installer found"
          else
            echo "‚úó Windows installer missing"
          fi
          
          # Check for macOS artifacts
          if ls *.dmg 1>/dev/null 2>&1; then
            MACOS_OK="true"
            echo "‚úì macOS DMG found"
          else
            echo "‚úó macOS DMG missing"
          fi
          
          echo "windows_ok=$WINDOWS_OK" >> $GITHUB_OUTPUT
          echo "macos_ok=$MACOS_OK" >> $GITHUB_OUTPUT
          
          if [ "$WINDOWS_OK" == "false" ] && [ "$MACOS_OK" == "false" ]; then
            echo "::error::No artifacts available for release"
            exit 1
          fi

      - name: Prepare assets
        working-directory: dist
        run: |
          TIMESTAMP=$(date -u +%Y%m%d)

          # Flatten directory structure - extract files from subdirectories
          find . -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.zip" \) -exec mv {} . \; 2>/dev/null || true

          # Remove empty directories
          find . -type d -empty -delete 2>/dev/null || true

          # Remove existing checksums if they exist
          rm -f checksums.txt

          # Rename artifacts to nightly format
          for file in *; do
            # Skip if it's not a file
            [ -f "$file" ] || continue

            if [[ "$file" == AccessiWeather_Setup_*.exe ]]; then
              mv "$file" "AccessiWeather-nightly-${TIMESTAMP}-windows-setup.exe"
            elif [[ "$file" == *.dmg ]]; then
              mv "$file" "AccessiWeather-nightly-${TIMESTAMP}-macOS.dmg"
            elif [[ "$file" == AccessiWeather_Portable_*.zip ]]; then
              mv "$file" "AccessiWeather-nightly-${TIMESTAMP}-windows-portable.zip"
            fi
          done

          # Generate new checksums
          sha256sum *.exe *.dmg *.zip 2>/dev/null > checksums.txt || true

          echo "Prepared assets:"
          ls -la

      - name: Extract changelog and generate release notes
        id: notes
        env:
          PREVIOUS_TAG: ${{ needs.prepare.outputs.previous_tag }}
          WINDOWS_OK: ${{ steps.validate.outputs.windows_ok }}
          MACOS_OK: ${{ steps.validate.outputs.macos_ok }}
        run: |
          git fetch --tags
          
          echo "Previous nightly tag: $PREVIOUS_TAG"
          
          # Generate release notes with Python for robustness
          python3 << 'PYTHON_EOF'
          import subprocess
          import os
          import re
          import sys

          previous_tag = os.environ.get("PREVIOUS_TAG", "")
          windows_ok = os.environ.get("WINDOWS_OK", "false") == "true"
          macos_ok = os.environ.get("MACOS_OK", "false") == "true"

          notes = []

          # Add build status warning if partial
          if not (windows_ok and macos_ok):
              missing = []
              if not windows_ok:
                  missing.append("Windows")
              if not macos_ok:
                  missing.append("macOS")
              notes.append(f"> ‚ö†Ô∏è **Partial build**: {', '.join(missing)} build(s) failed\n")

          notes.append("## What's New\n")

          changelog_entries = []
          
          # Try to extract CHANGELOG entries
          try:
              if previous_tag:
                  # Get diff of CHANGELOG.md
                  result = subprocess.run(
                      ["git", "diff", f"{previous_tag}..HEAD", "--", "CHANGELOG.md"],
                      capture_output=True, text=True, timeout=30
                  )
                  if result.returncode == 0 and result.stdout:
                      # Extract added lines
                      for line in result.stdout.split('\n'):
                          if line.startswith('+') and not line.startswith('+++'):
                              content = line[1:]
                              # Skip empty section headers and placeholder dashes
                              if content.strip() and content.strip() != '-':
                                  # Skip lines that are just section headers with no content following
                                  changelog_entries.append(content)
              else:
                  # First nightly - extract Unreleased section
                  with open("CHANGELOG.md", 'r') as f:
                      content = f.read()
                  pattern = r'## \[?Unreleased\]?.*?\n(.*?)(?=\n## \[|$)'
                  match = re.search(pattern, content, re.DOTALL)
                  if match:
                      for line in match.group(1).strip().split('\n'):
                          if line.strip() and line.strip() != '-':
                              changelog_entries.append(line)
          except Exception as e:
              print(f"Warning: Could not extract CHANGELOG: {e}", file=sys.stderr)

          # Filter out empty section headers
          filtered_entries = []
          skip_next_dash = False
          for i, entry in enumerate(changelog_entries):
              if entry.startswith('### '):
                  # Check if this section has content
                  has_content = False
                  for j in range(i + 1, len(changelog_entries)):
                      if changelog_entries[j].startswith('### '):
                          break
                      if changelog_entries[j].strip() and changelog_entries[j].strip() != '-':
                          if not changelog_entries[j].startswith('### '):
                              has_content = True
                              break
                  if has_content:
                      filtered_entries.append(entry)
              elif entry.strip() != '-':
                  filtered_entries.append(entry)

          if filtered_entries:
              notes.append('\n'.join(filtered_entries))
          else:
              # Fallback: list recent commits
              notes.append("### Recent Changes\n")
              try:
                  if previous_tag:
                      result = subprocess.run(
                          ["git", "log", f"{previous_tag}..HEAD", "--oneline", "--no-merges", "-20"],
                          capture_output=True, text=True, timeout=30
                      )
                  else:
                      result = subprocess.run(
                          ["git", "log", "--oneline", "--no-merges", "-20"],
                          capture_output=True, text=True, timeout=30
                      )
                  if result.returncode == 0 and result.stdout.strip():
                      for line in result.stdout.strip().split('\n'):
                          # Format: hash message -> - message
                          parts = line.split(' ', 1)
                          if len(parts) == 2:
                              notes.append(f"- {parts[1]}")
                  else:
                      notes.append("_No changes documented._")
              except Exception as e:
                  notes.append(f"_Could not retrieve commit history: {e}_")

          notes.append("\n---\n")
          notes.append("## Download\n")
          notes.append("Choose your platform below. Checksums available in `checksums.txt`.\n")

          # Write release notes
          with open("release-notes.md", 'w') as f:
              f.write('\n'.join(notes))

          print("Generated release notes:")
          print('\n'.join(notes))
          PYTHON_EOF

      - name: Generate PR-based notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PREVIOUS_TAG: ${{ needs.prepare.outputs.previous_tag }}
        run: |
          TAG="nightly-$(date -u +%Y%m%d)"
          
          echo "" >> release-notes.md
          echo "## Pull Requests & Commits" >> release-notes.md
          echo "" >> release-notes.md

          if [ -n "$PREVIOUS_TAG" ]; then
            # Use GitHub API to generate notes between tags
            PR_NOTES=$(gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              repos/${{ github.repository }}/releases/generate-notes \
              -f tag_name="$TAG" \
              -f target_commitish="dev" \
              -f previous_tag_name="$PREVIOUS_TAG" \
              --jq '.body' 2>/dev/null || echo "")

            if [ -n "$PR_NOTES" ]; then
              echo "$PR_NOTES" >> release-notes.md
            else
              echo "_No pull requests merged since last nightly._" >> release-notes.md
            fi
          else
            echo "_First nightly build - no previous release to compare._" >> release-notes.md
          fi

          echo ""
          echo "Final release notes:"
          cat release-notes.md

      - name: Create Prerelease
        if: ${{ inputs.dry_run != true }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="nightly-$(date -u +%Y%m%d)"
          TITLE="Nightly $(date -u +%Y-%m-%d)"

          # Delete existing release/tag if re-running for the same day
          gh release delete "$TAG" -y --cleanup-tag 2>/dev/null || true

          # Build file list from dist/ (only existing files)
          FILES=""
          for f in dist/*.exe dist/*.dmg dist/*.zip dist/checksums.txt; do
            [ -f "$f" ] && FILES="$FILES $f"
          done
          
          if [ -n "$FILES" ]; then
            gh release create "$TAG" $FILES \
              --title "$TITLE" \
              --notes-file release-notes.md \
              --prerelease \
              --target dev
            echo "‚úì Release created: $TAG"
          else
            echo "::error::No files to release"
            exit 1
          fi

      - name: Dry run summary
        if: ${{ inputs.dry_run == true }}
        run: |
          echo "üèÉ DRY RUN - No release created"
          echo ""
          echo "Would have created release with:"
          echo "- Tag: nightly-$(date -u +%Y%m%d)"
          echo "- Title: Nightly $(date -u +%Y-%m-%d)"
          echo ""
          echo "Assets:"
          ls -la dist/
          echo ""
          echo "Release notes:"
          cat release-notes.md

  trigger-pages-update:
    name: Trigger Pages Update
    needs: [prepare, nightly-release]
    if: |
      always() &&
      needs.prepare.outputs.changed == 'true' &&
      needs.nightly-release.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Trigger update-pages workflow
        if: ${{ inputs.dry_run != true }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh workflow run update-pages.yml \
            --repo ${{ github.repository }} \
            -f force_update=true \
            -f target_branch=both
